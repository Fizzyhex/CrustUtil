[{"title":"ParallelComponent","type":0,"sectionRef":"#","url":"/CrustUtil/api/ParallelComponent","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ParallelComponent","url":"/CrustUtil/api/ParallelComponent#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ParallelComponent","url":"/CrustUtil/api/ParallelComponent#new","content":"&lt;/&gt; ParallelComponent.new(config: ComponentConfig) → ComponentClass Constructs a new Parallel Component. local MyComponent = ParallelComponent.new { Tag = &quot;MyComponent&quot; ParallelInstance = script:FindFirstChild(&quot;ParallelInstance&quot;) -- Required! }   "},{"title":"LoadComponent​","type":1,"pageTitle":"ParallelComponent","url":"/CrustUtil/api/ParallelComponent#LoadComponent","content":"&lt;/&gt; ParallelComponent:LoadComponent( module: Instance -- The ModuleScript to load ) → () Used to load a component. This should be used instead of requiring the component directly! "},{"title":"ParallelRequire","type":0,"sectionRef":"#","url":"/CrustUtil/api/ParallelRequire","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ParallelRequire","url":"/CrustUtil/api/ParallelRequire#types","content":" "},{"title":"Executor​","type":1,"pageTitle":"ParallelRequire","url":"/CrustUtil/api/ParallelRequire#Executor","content":"&lt;/&gt; type Executor = ModuleScript  An executor is a ModuleScript that is used to load ModuleScripts that are required. An instance of an executor is created per ModuleScript that is required. -- This is the default Executor ModuleScript. -- When an executor is required, it will have an ObjectValue parented to it that points to the module that needs to be required. require(script.module.Value) return nil -- Example Executor that requires the module and then calls its 'OnStart' method too. local module = require(script.module.Value) if module.OnStart then module:OnStart() end return nil caution Executors must return something, as they are ModuleScripts! Because the returned value won't be used, you should just return nil. note Executors are created per ModuleScript, so it's safe to yield incide of them.  "},{"title":"ParallelRequireConfig​","type":1,"pageTitle":"ParallelRequire","url":"/CrustUtil/api/ParallelRequire#ParallelRequireConfig","content":"&lt;/&gt; type ParallelRequireConfig = { executor: Executor, container: Instance? } The configuration used when instantiating a new ParallelRequire object. "},{"title":"Functions​","type":1,"pageTitle":"ParallelRequire","url":"/CrustUtil/api/ParallelRequire#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ParallelRequire","url":"/CrustUtil/api/ParallelRequire#new","content":"&lt;/&gt; ParallelRequire.new(config: ParallelRequireConfig) → () An optional constructor that creates a new ParallelRequire object. tip You don't need to use the constructor to use the module. Only use the constructor if you need to use the ParallelRequireConfig parameter!  "},{"title":"Require​","type":1,"pageTitle":"ParallelRequire","url":"/CrustUtil/api/ParallelRequire#Require","content":"&lt;/&gt; ParallelRequire:Require( modules: ModuleScript | {ModuleScript },-- ModuleScript(s) to require executor: Executor-- The Executor that will be used to require the module ) → Actor  Requires the ModuleScript under a new Actor. If a table of modules is passed, they will all be placed under the same Actor. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/CrustUtil/docs/intro","content":"","keywords":""},{"title":"Wally Configuration​","type":1,"pageTitle":"Getting Started","url":"/CrustUtil/docs/intro#wally-configuration","content":"Once Wally is installed, run wally init on your project directory. This will create a brand new wally.toml file. You can then add any utilities you would like to your project as dependancies. For example: [package] name = &quot;your_name/your_project&quot; version = &quot;0.1.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] ParallelComponent = &quot;fizzyhex/parallelcomponent@0.1.0&quot;  To install or update these dependancies, run wally install within your project's terminal. Wally will then create a folder called 'Packages' with all of your installed dependancies! "},{"title":"Rojo Configuration​","type":1,"pageTitle":"Getting Started","url":"/CrustUtil/docs/intro#rojo-configuration","content":"I would suggest checking out this guide by Sleitnick for his RbxUtil modules, which inspired this guide! "},{"title":"Usage Example​","type":1,"pageTitle":"Getting Started","url":"/CrustUtil/docs/intro#usage-example","content":"Information about the respective packages can be found in the API section. Below is an example of a script using installed dependancies: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) -- Reference the packages folder: local Packages = ReplicatedStorage.Packages -- Require package: local UIComponent = require(Packages.UIComponent) local CreateInstance = UIComponent.CreateInstance -- Use the module: local Button = UIComponent.new() function Button:Build() self.button = CreateInstance &quot;TextButton&quot; { Size = UDim2.new(0, 200, 0, 50), Text = &quot;Click Me!&quot; TextColor3 = self.props.textColor, Parent = self.props.parent } end local gui = CreateInstance(&quot;ScreenGui&quot;, {Parent = LOCAL_PLAYER.PlayerGui}) local newButton = Button{textColor = Color3.new(1, 0.5, 0.5), parent = gui}  "},{"title":"Component","type":0,"sectionRef":"#","url":"/CrustUtil/api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#types","content":" "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → ()   "},{"title":"ExtensionShouldFn​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#ExtensionShouldFn","content":"&lt;/&gt; type ExtensionShouldFn = (component) → boolean   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Extension","content":"&lt;/&gt; interface Extension { ShouldExtend: ExtensionShouldFn? ShouldConstruct: ExtensionShouldFn? Constructing: ExtensionFn? Constructed: ExtensionFn? Starting: ExtensionFn? Started: ExtensionFn? Stopping: ExtensionFn? Stopped: ExtensionFn? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components by wrapping around component lifecycle methods. The ShouldConstruct function can be used to indicate if the component should actually be created. This must return true or false. A component with multiple ShouldConstruct extension functions must have them all return true in order for the component to be constructed. The ShouldConstruct function runs before all other extension functions and component lifecycle methods. The ShouldExtend function can be used to indicate if the extension itself should be used. This can be used in order to toggle an extension on/off depending on whatever logic is appropriate. If no ShouldExtend function is provided, the extension will always be used if provided as an extension to the component. As an example, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.Constructing(component) print(&quot;Constructing&quot;, component) end function Logger.Constructed(component) print(&quot;Constructed&quot;, component) end function Logger.Starting(component) print(&quot;Starting&quot;, component) end function Logger.Started(component) print(&quot;Started&quot;, component) end function Logger.Stopping(component) print(&quot;Stopping&quot;, component) end function Logger.Stopped(component) print(&quot;Stopped&quot;, component) end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {Logger}}) Sometimes it is useful for an extension to control whether or not a component should be constructed. For instance, if a component on the client should only be instantiated for the local player, an extension might look like this, assuming the instance has an attribute linking it to the player's UserId: local player = game:GetService(&quot;Players&quot;).LocalPlayer local OnlyLocalPlayer = {} function OnlyLocalPlayer.ShouldConstruct(component) local ownerId = component.Instance:GetAttribute(&quot;OwnerId&quot;) return ownerId == player.UserId end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {OnlyLocalPlayer}}) It can also be useful for an extension itself to turn on/off depending on various contexts. For example, let's take the Logger from the first example, and only use that extension if the bound instance has a Log attribute set to true: function Logger.ShouldExtend(component) return component.Instance:GetAttribute(&quot;Log&quot;) == true end   "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { Tag: string-- CollectionService tag to use Ancestors: {Instance }?-- Optional array of ancestors in which components will be started Extensions: {Extension}?-- Optional array of extension objects } Component configuration passed to Component.new. If no Ancestors option is included, it defaults to {workspace, game.Players}. If no Extensions option is included, it defaults to a blank table {}.  "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → ()   "},{"title":"ExtensionShouldFn​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#ExtensionShouldFn","content":"&lt;/&gt; type ExtensionShouldFn = (component) → boolean   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Extension","content":"&lt;/&gt; interface Extension { ShouldExtend: ExtensionShouldFn? ShouldConstruct: ExtensionShouldFn? Constructing: ExtensionFn? Constructed: ExtensionFn? Starting: ExtensionFn? Started: ExtensionFn? Stopping: ExtensionFn? Stopped: ExtensionFn? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components by wrapping around component lifecycle methods. The ShouldConstruct function can be used to indicate if the component should actually be created. This must return true or false. A component with multiple ShouldConstruct extension functions must have them all return true in order for the component to be constructed. The ShouldConstruct function runs before all other extension functions and component lifecycle methods. The ShouldExtend function can be used to indicate if the extension itself should be used. This can be used in order to toggle an extension on/off depending on whatever logic is appropriate. If no ShouldExtend function is provided, the extension will always be used if provided as an extension to the component. As an example, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.Constructing(component) print(&quot;Constructing&quot;, component) end function Logger.Constructed(component) print(&quot;Constructed&quot;, component) end function Logger.Starting(component) print(&quot;Starting&quot;, component) end function Logger.Started(component) print(&quot;Started&quot;, component) end function Logger.Stopping(component) print(&quot;Stopping&quot;, component) end function Logger.Stopped(component) print(&quot;Stopped&quot;, component) end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {Logger}}) Sometimes it is useful for an extension to control whether or not a component should be constructed. For instance, if a component on the client should only be instantiated for the local player, an extension might look like this, assuming the instance has an attribute linking it to the player's UserId: local player = game:GetService(&quot;Players&quot;).LocalPlayer local OnlyLocalPlayer = {} function OnlyLocalPlayer.ShouldConstruct(component) local ownerId = component.Instance:GetAttribute(&quot;OwnerId&quot;) return ownerId == player.UserId end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {OnlyLocalPlayer}}) It can also be useful for an extension itself to turn on/off depending on various contexts. For example, let's take the Logger from the first example, and only use that extension if the bound instance has a Log attribute set to true: function Logger.ShouldExtend(component) return component.Instance:GetAttribute(&quot;Log&quot;) == true end   "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { Tag: string-- CollectionService tag to use Ancestors: {Instance }?-- Optional array of ancestors in which components will be started Extensions: {Extension}?-- Optional array of extension objects } Component configuration passed to Component.new. If no Ancestors option is included, it defaults to {workspace, game.Players}. If no Extensions option is included, it defaults to a blank table {}. "},{"title":"Properties​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#properties","content":" "},{"title":"Started​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Started","content":"Event Component Class &lt;/&gt; Component.Started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Started:Connect(function(component) end)   "},{"title":"Stopped​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Stopped","content":"Event Component Class &lt;/&gt; Component.Stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Stopped:Connect(function(component) end)   "},{"title":"Instance​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Instance","content":"Component Instance &lt;/&gt; Component.Instance: Instance  A reference back to the Roblox instance from within a component instance. When a component instance is created, it is bound to a specific Roblox instance, which will always be present through the Instance property. MyComponent.Started:Connect(function(component) local robloxInstance: Instance = component.Instance print(&quot;Component is bound to &quot; .. robloxInstance:GetFullName()) end)   "},{"title":"Started​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Started","content":"Event Component Class &lt;/&gt; Component.Started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Started:Connect(function(component) end)   "},{"title":"Stopped​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Stopped","content":"Event Component Class &lt;/&gt; Component.Stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Stopped:Connect(function(component) end)   "},{"title":"Instance​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Instance","content":"Component Instance &lt;/&gt; Component.Instance: Instance  A reference back to the Roblox instance from within a component instance. When a component instance is created, it is bound to a specific Roblox instance, which will always be present through the Instance property. MyComponent.Started:Connect(function(component) local robloxInstance: Instance = component.Instance print(&quot;Component is bound to &quot; .. robloxInstance:GetFullName()) end)  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#new","content":"Component &lt;/&gt; Component.new(config: ComponentConfig) → ComponentClass Create a new custom Component class. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) A full example might look like this: local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, Extensions = {Logger}, -- See Logger example within the example for the Extension type }) local AnotherComponent = require(somewhere.AnotherComponent) -- Optional if UpdateRenderStepped should use BindToRenderStep: MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:Construct() self.MyData = &quot;Hello&quot; end function MyComponent:Start() local another = self:GetComponent(AnotherComponent) another:DoSomething() end function MyComponent:Stop() self.MyData = &quot;Goodbye&quot; end function MyComponent:HeartbeatUpdate(dt) end function MyComponent:SteppedUpdate(dt) end function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"HeartbeatUpdate​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#HeartbeatUpdate","content":"Component Class &lt;/&gt; Component.HeartbeatUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Heartbeat. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:HeartbeatUpdate(dt) end   "},{"title":"SteppedUpdate​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#SteppedUpdate","content":"Component Class &lt;/&gt; Component.SteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Stepped. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:SteppedUpdate(dt) end   "},{"title":"RenderSteppedUpdate​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#RenderSteppedUpdate","content":"This item only works when running on the client. Client Component Class &lt;/&gt; Component.RenderSteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.RenderStepped. If the [Component].RenderPriority field is found, then the component will instead use RunService:BindToRenderStep() to bind the function. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. -- Example that uses `RunService.RenderStepped` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:RenderSteppedUpdate(dt) end -- Example that uses `RunService:BindToRenderStep` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- Defining a RenderPriority will force the component to use BindToRenderStep instead MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"GetAll​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#GetAll","content":"Component Class &lt;/&gt; Component:GetAll() → {Component} Gets a table array of all existing component objects. For example, if there was a component class linked to the &quot;MyComponent&quot; tag, and three Roblox instances in your game had that same tag, then calling GetAll would return the three component instances. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- ... local components = MyComponent:GetAll() for _,component in ipairs(components) do component:DoSomethingHere() end   "},{"title":"FromInstance​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#FromInstance","content":"Component Class &lt;/&gt; Component:FromInstance(instance: Instance ) → Component? Gets an instance of a component class from the given Roblox instance. Returns nil if not found. local MyComponent = require(somewhere.MyComponent) local myComponentInstance = MyComponent:FromInstance(workspace.SomeInstance)   "},{"title":"WaitForInstance​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#WaitForInstance","content":"Component Class &lt;/&gt; Component:WaitForInstance( instance: Instance , timeout: number? ) → Promise&lt;ComponentInstance&gt; Resolves a promise once the component instance is present on a given Roblox instance. An optional timeout can be provided to reject the promise if it takes more than timeout seconds to resolve. If no timeout is supplied, timeout defaults to 60 seconds. local MyComponent = require(somewhere.MyComponent) MyComponent:WaitForInstance(workspace.SomeInstance):andThen(function(myComponentInstance) -- Do something with the component class end)   "},{"title":"Construct​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Construct","content":"Component Class &lt;/&gt; Component:Construct() → () Construct is called before the component is started, and should be used to construct the component instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Construct() self.SomeData = 32 self.OtherStuff = &quot;HelloWorld&quot; end   "},{"title":"Start​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Start","content":"Component Class &lt;/&gt; Component:Start() → () Start is called when the component is started. At this point in time, it is safe to grab other components also bound to the same instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() -- e.g., grab another component: local another = self:GetComponent(AnotherComponent) end   "},{"title":"Stop​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#Stop","content":"Component Class &lt;/&gt; Component:Stop() → () Stop is called when the component is stopped. This occurs either when the bound instance is removed from one of the whitelisted ancestors or when the matching tag is removed from the instance. This also means that the instance might be destroyed, and thus it is not safe to continue using the bound instance (e.g. self.Instance) any longer. This should be used to clean up the component. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Stop() self.SomeStuff:Destroy() end   "},{"title":"GetComponent​","type":1,"pageTitle":"Component","url":"/CrustUtil/api/Component#GetComponent","content":"Component Instance &lt;/&gt; Component:GetComponent(componentClass: ComponentClass) → Component? Retrieves another component instance bound to the same Roblox instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() local another = self:GetComponent(AnotherComponent) end  "}]