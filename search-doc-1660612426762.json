[{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Wally Configuration​","type":1,"pageTitle":"Getting Started","url":"docs/intro#wally-configuration","content":"Once Wally is installed, run wally init on your project directory. This will create a brand new wally.toml file. You can then add any utilities you would like to your project as dependancies. For example: [package] name = &quot;your_name/your_project&quot; version = &quot;0.1.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] ParallelComponent = &quot;fizzyhex/parallelcomponent@0.1.0&quot; Copy To install or update these dependancies, run wally install within your project's terminal. Wally will then create a folder called 'Packages' with all of your installed dependancies! "},{"title":"Rojo Configuration​","type":1,"pageTitle":"Getting Started","url":"docs/intro#rojo-configuration","content":"I would suggest checking out this guide by Sleitnick for his RbxUtil modules, which inspired this guide! "},{"title":"Usage Example​","type":1,"pageTitle":"Getting Started","url":"docs/intro#usage-example","content":"Information about the respective packages can be found in the API section. Below is an example of a script using installed dependancies: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) -- Reference the packages folder: local Packages = ReplicatedStorage.Packages -- Require package: local UIComponent = require(Packages.UIComponent) local CreateInstance = UIComponent.CreateInstance -- Use the module: local Button = UIComponent.new() function Button:Build() self.button = CreateInstance &quot;TextButton&quot; { Size = UDim2.new(0, 200, 0, 50), Text = &quot;Click Me!&quot; TextColor3 = self.props.textColor, Parent = self.props.parent } end local gui = CreateInstance(&quot;ScreenGui&quot;, {Parent = LOCAL_PLAYER.PlayerGui}) local newButton = Button{textColor = Color3.new(1, 0.5, 0.5), parent = gui} Copy "},{"title":"ParallelComponent","type":0,"sectionRef":"#","url":"api/ParallelComponent","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ParallelComponent","url":"api/ParallelComponent#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ParallelComponent","url":"api/ParallelComponent#new","content":"&lt;/&gt; ParallelComponent.new(config: ComponentConfig) → ComponentClass Constructs a new Parallel Component. local MyComponent = ParallelComponent.new({Tag = &quot;MyComponent&quot;})   "},{"title":"LoadComponent​","type":1,"pageTitle":"ParallelComponent","url":"api/ParallelComponent#LoadComponent","content":"&lt;/&gt; ParallelComponent:LoadComponent( module: Instance -- The ModuleScript to load ) → () Used to load a component. This should be used instead of requiring the component directly! "},{"title":"KnitUtil","type":0,"sectionRef":"#","url":"api/KnitUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"KnitUtil","url":"api/KnitUtil#functions","content":" "},{"title":"LoadComponents​","type":1,"pageTitle":"KnitUtil","url":"api/KnitUtil#LoadComponents","content":"&lt;/&gt; KnitUtil.LoadComponents( container: Instance -- The folder containing the Components ) → table{Component} Requires all children of the provided Instance. -- Require the module local KnitUtil = require(somewhere.KnitUtil) -- Locate components folder local componentsFolder = ReplicatedStorage.Client.Components -- Load all of the components local components = KnitUtil.LoadComponents(componentsFolder)   "},{"title":"MethodFromInstance​","type":1,"pageTitle":"KnitUtil","url":"api/KnitUtil#MethodFromInstance","content":"&lt;/&gt; KnitUtil.MethodFromInstance( instance: Instance ,-- The Instance to search methodName: string-- The name of the method to look for ) → ( methodfunction?,-- The method that was found componentComponent?-- The component instance the method belongs to ) Searches all the Instance's components for a specific method. Writing cleaner code with MethodFromInstance Let's say we have two components: a door and a light switch. We want to write a script to interact with these objects and any new ones we may come up with in the future: Door Component local Door = Component.new { Tag = &quot;Door&quot; } function Door:_open() print(&quot;Door open&quot;) self.isOpen = true end function Door:_close() print(&quot;Door closed&quot;) self.isOpen = false end function Door:OnInteract(open: boolean) if open then if self.isOpen then self:_close() else self:_open() end end end function Door:Construct() self.isOpen = false end Light Switch Component local LightSwitch = Component.new { Tag = &quot;LightSwitch&quot; } function LightSwitch:_turnOn() print(&quot;Light on&quot;) self.isOn = true end function LightSwitch:_turnOff() print(&quot;Light off&quot;) self.isOn = false end function LightSwitch:OnInteract(on: boolean) if on then if self.isOn then self:_turnOff() else self:_turnOn() end end end function LightSwitch:Construct() self.isOn = false end Interaction Script (without MethodFromInstance) Without MethodFromInstance, we might write some interaction code like this: -- Require components we can interact with local DoorComponent = require(somewhere.Components.DoorComponent) local LightSwitchComponent = require(somewhere.Components.LightSwitch) local function InteractWith(instance: Instance) -- Scan through the Instance's components for an 'OnInteract' method if CollectionService:HasTag(instance, &quot;Door&quot;) then DoorComponent:FromInstance(instance):OnInteract(true) elseif CollectionService:HasTag(instance, &quot;LightSwitch&quot;) then LightSwitchComponent:FromInstance(instance):OnInteract(true) else if ....... then -- etc etc etc ..... end end -- Open the door InteractWith(workspace.Door) -- Flick the light switch to on InteractWith(workspace.LightSwitch) Final Result (using MethodFromInstance) This code is bad because it will get messy as we add more types of Components to our game. However, if we instead use MethodFromInstance we don't need to modify the code every time we create a new component. Below is an example that implements MethodFromInstance: local function InteractWith(instance: Instance) -- Scan through the Instance's components for an 'OnInteract' method local onInteract = KnitUtil.MethodFromInstance(instance, &quot;OnInteract&quot;) if onInteract then -- Call the method onInteract(true) end end -- Open the door InteractWith(workspace.Door) -- Flick the light switch to on InteractWith(workspace.LightSwitch)   "},{"title":"VariableFromInstance​","type":1,"pageTitle":"KnitUtil","url":"api/KnitUtil#VariableFromInstance","content":"&lt;/&gt; KnitUtil.VariableFromInstance( instance: Instance ,-- The Instance to search variableName: string-- The variable to look for ) → ( variableany,-- The variable that was found componentComponent?-- The component instance the method belongs to ) Similar to MethodFromInstance, but for non-methods. local function GetHealth(enemy: Instance) local health: number? = KnitUtil.VariableFromInstance(enemy, &quot;MyHealth&quot;) return health end print(GetHealth(workspace.Zombie)) print(GetHealth(workspace.Player)) print(GetHealth(workspace.DestructableBox))  "},{"title":"UIComponent","type":0,"sectionRef":"#","url":"api/UIComponent","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#functions","content":" "},{"title":"CreateInstance​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#CreateInstance","content":"&lt;/&gt; UIComponent.CreateInstance( className: string,-- The class name of the Instance you want to create props: table-- The properties of the instance you want to create ) → Instance -- Returns a new Instance A utility for creating Instances. local smokeyCube = CreateInstance(&quot;BasePart&quot;, { Name = &quot;SmokeyCube&quot;, Anchored = true, Size = Vector3.new(4, 4, 4) Parent = workspace [UIComponent.Children] = CreateInstance(&quot;Smoke&quot;, { Size = 4 }) }) -- ...which is equivalent to: local smokeyCube = Instance.new(&quot;BasePart&quot;) smokeyCube.Name = &quot;SmokeyCube&quot; smokeyCube.Anchored = true smokeyCube.Size = Vector3.new(4, 4, 4) smokeyCube.Parent = workspace local smoke = Instance.new(&quot;Smoke&quot;) smoke.Size = 4 smoke.Parent = smokeyCube Assigning children Assigning children can be done within the CreateInstance function. The simplist way to do this is to simply pass a child: local gui = CreateInstance(&quot;ScreenGui&quot;, { Parent = PlayerGui, Children = CreateInstance(&quot;Frame&quot;, { Size = UDim2.new(0, 50, 0, 50), }), }) Or a table for multiple children: local gui = CreateInstance(&quot;ScreenGui&quot;, { Parent = PlayerGui, Children = { CreateInstance(&quot;Frame&quot;, { Size = UDim2.new(0, 50, 0, 50), }), CreateInstance(&quot;TextButton&quot;, { Size = UDim2.new(0, 50, 0, 50), }), } }) If you ever need to, you can also specify multiple children under different keys using the UIComponent.Children Enum: local gui = CreateInstance(&quot;ScreenGui&quot;, { Parent = PlayerGui, [UIComponent.Children] = { CreateInstance(&quot;Frame&quot;, { Size = UDim2.new(0, 50, 0, 50), }), } [UIComponent.Children] = { CreateInstance(&quot;TextButton&quot;, { Size = UDim2.new(0, 50, 0, 50), }), } })   "},{"title":"Is​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#Is","content":"&lt;/&gt; UIComponent.Is( thing: any-- Object to check ) → boolean-- true if object is a UIComponent. Checks if the given object is a UIComponent object.  "},{"title":"new​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#new","content":"&lt;/&gt; UIComponent.new() → UIComponent Creates a new UIComponent class. local newComponent = UIComponent.new()   "},{"title":"GetInstance​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#GetInstance","content":"&lt;/&gt; UIComponent:GetInstance() → Instance  Returns the Instance returned by the component when it was built. This function will error if the component does not have an Instance. local Button = UIComponent.new() function Button:Build() return CreateInstance &quot;TextButton&quot; { Name = &quot;FriendlyButton&quot;, Size = UDim2.new(0, 100, 0, 50), Text = self.props.Text, }, self.props end local newButton, _, props = Button {Text = &quot;Hello World!&quot;} print(newButton:GetInstance()) print(props) &gt; FriendlyButton &gt; { Text = &quot;Hello World!&quot; }   "},{"title":"Build​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#Build","content":"&lt;/&gt; UIComponent:Build() → self,...-- Returns the object and any provided arguments Build is called during the UIComponent's creation. Build should not be called to create a new Instance of a UIComponent. Instead, call it like a function. local UIComponent = require(somewhere.UIComponent) local PersistentGui = UIComponent.new() function PersistentGui:Build() self.gui = CreateInstance(&quot;ScreenGui&quot;, { Name = &quot;PersistentGui&quot;, ResetOnSpawn = false, ZIndex = self.props.ZIndex, Parent = LOCAL_PLAYER.PlayerGui }) return self.gui, tick() end local persistentGui, _, creationTime = MainGui.new{ ZIndex = 3 } print(&quot;Created GUI at&quot;, creationTime)   "},{"title":"Defer​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#Defer","content":"&lt;/&gt; UIComponent:Defer() → () Defer is called after Build and will not yield the thread. "},{"title":"Component","type":0,"sectionRef":"#","url":"api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"api/Component#types","content":" "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → ()   "},{"title":"ExtensionShouldFn​","type":1,"pageTitle":"Component","url":"api/Component#ExtensionShouldFn","content":"&lt;/&gt; type ExtensionShouldFn = (component) → boolean   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"api/Component#Extension","content":"&lt;/&gt; interface Extension { ShouldExtend: ExtensionShouldFn? ShouldConstruct: ExtensionShouldFn? Constructing: ExtensionFn? Constructed: ExtensionFn? Starting: ExtensionFn? Started: ExtensionFn? Stopping: ExtensionFn? Stopped: ExtensionFn? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components by wrapping around component lifecycle methods. The ShouldConstruct function can be used to indicate if the component should actually be created. This must return true or false. A component with multiple ShouldConstruct extension functions must have them all return true in order for the component to be constructed. The ShouldConstruct function runs before all other extension functions and component lifecycle methods. The ShouldExtend function can be used to indicate if the extension itself should be used. This can be used in order to toggle an extension on/off depending on whatever logic is appropriate. If no ShouldExtend function is provided, the extension will always be used if provided as an extension to the component. As an example, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.Constructing(component) print(&quot;Constructing&quot;, component) end function Logger.Constructed(component) print(&quot;Constructed&quot;, component) end function Logger.Starting(component) print(&quot;Starting&quot;, component) end function Logger.Started(component) print(&quot;Started&quot;, component) end function Logger.Stopping(component) print(&quot;Stopping&quot;, component) end function Logger.Stopped(component) print(&quot;Stopped&quot;, component) end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {Logger}}) Sometimes it is useful for an extension to control whether or not a component should be constructed. For instance, if a component on the client should only be instantiated for the local player, an extension might look like this, assuming the instance has an attribute linking it to the player's UserId: local player = game:GetService(&quot;Players&quot;).LocalPlayer local OnlyLocalPlayer = {} function OnlyLocalPlayer.ShouldConstruct(component) local ownerId = component.Instance:GetAttribute(&quot;OwnerId&quot;) return ownerId == player.UserId end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {OnlyLocalPlayer}}) It can also be useful for an extension itself to turn on/off depending on various contexts. For example, let's take the Logger from the first example, and only use that extension if the bound instance has a Log attribute set to true: function Logger.ShouldExtend(component) return component.Instance:GetAttribute(&quot;Log&quot;) == true end   "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { Tag: string-- CollectionService tag to use Ancestors: {Instance }?-- Optional array of ancestors in which components will be started Extensions: {Extension}?-- Optional array of extension objects } Component configuration passed to Component.new. If no Ancestors option is included, it defaults to {workspace, game.Players}. If no Extensions option is included, it defaults to a blank table {}.  "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → ()   "},{"title":"ExtensionShouldFn​","type":1,"pageTitle":"Component","url":"api/Component#ExtensionShouldFn","content":"&lt;/&gt; type ExtensionShouldFn = (component) → boolean   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"api/Component#Extension","content":"&lt;/&gt; interface Extension { ShouldExtend: ExtensionShouldFn? ShouldConstruct: ExtensionShouldFn? Constructing: ExtensionFn? Constructed: ExtensionFn? Starting: ExtensionFn? Started: ExtensionFn? Stopping: ExtensionFn? Stopped: ExtensionFn? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components by wrapping around component lifecycle methods. The ShouldConstruct function can be used to indicate if the component should actually be created. This must return true or false. A component with multiple ShouldConstruct extension functions must have them all return true in order for the component to be constructed. The ShouldConstruct function runs before all other extension functions and component lifecycle methods. The ShouldExtend function can be used to indicate if the extension itself should be used. This can be used in order to toggle an extension on/off depending on whatever logic is appropriate. If no ShouldExtend function is provided, the extension will always be used if provided as an extension to the component. As an example, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.Constructing(component) print(&quot;Constructing&quot;, component) end function Logger.Constructed(component) print(&quot;Constructed&quot;, component) end function Logger.Starting(component) print(&quot;Starting&quot;, component) end function Logger.Started(component) print(&quot;Started&quot;, component) end function Logger.Stopping(component) print(&quot;Stopping&quot;, component) end function Logger.Stopped(component) print(&quot;Stopped&quot;, component) end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {Logger}}) Sometimes it is useful for an extension to control whether or not a component should be constructed. For instance, if a component on the client should only be instantiated for the local player, an extension might look like this, assuming the instance has an attribute linking it to the player's UserId: local player = game:GetService(&quot;Players&quot;).LocalPlayer local OnlyLocalPlayer = {} function OnlyLocalPlayer.ShouldConstruct(component) local ownerId = component.Instance:GetAttribute(&quot;OwnerId&quot;) return ownerId == player.UserId end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {OnlyLocalPlayer}}) It can also be useful for an extension itself to turn on/off depending on various contexts. For example, let's take the Logger from the first example, and only use that extension if the bound instance has a Log attribute set to true: function Logger.ShouldExtend(component) return component.Instance:GetAttribute(&quot;Log&quot;) == true end   "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { Tag: string-- CollectionService tag to use Ancestors: {Instance }?-- Optional array of ancestors in which components will be started Extensions: {Extension}?-- Optional array of extension objects } Component configuration passed to Component.new. If no Ancestors option is included, it defaults to {workspace, game.Players}. If no Extensions option is included, it defaults to a blank table {}. "},{"title":"Properties​","type":1,"pageTitle":"Component","url":"api/Component#properties","content":" "},{"title":"Started​","type":1,"pageTitle":"Component","url":"api/Component#Started","content":"Event Component Class &lt;/&gt; Component.Started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Started:Connect(function(component) end)   "},{"title":"Stopped​","type":1,"pageTitle":"Component","url":"api/Component#Stopped","content":"Event Component Class &lt;/&gt; Component.Stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Stopped:Connect(function(component) end)   "},{"title":"Instance​","type":1,"pageTitle":"Component","url":"api/Component#Instance","content":"Component Instance &lt;/&gt; Component.Instance: Instance  A reference back to the Roblox instance from within a component instance. When a component instance is created, it is bound to a specific Roblox instance, which will always be present through the Instance property. MyComponent.Started:Connect(function(component) local robloxInstance: Instance = component.Instance print(&quot;Component is bound to &quot; .. robloxInstance:GetFullName()) end)   "},{"title":"Started​","type":1,"pageTitle":"Component","url":"api/Component#Started","content":"Event Component Class &lt;/&gt; Component.Started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Started:Connect(function(component) end)   "},{"title":"Stopped​","type":1,"pageTitle":"Component","url":"api/Component#Stopped","content":"Event Component Class &lt;/&gt; Component.Stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Stopped:Connect(function(component) end)   "},{"title":"Instance​","type":1,"pageTitle":"Component","url":"api/Component#Instance","content":"Component Instance &lt;/&gt; Component.Instance: Instance  A reference back to the Roblox instance from within a component instance. When a component instance is created, it is bound to a specific Roblox instance, which will always be present through the Instance property. MyComponent.Started:Connect(function(component) local robloxInstance: Instance = component.Instance print(&quot;Component is bound to &quot; .. robloxInstance:GetFullName()) end)  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"api/Component#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Component","url":"api/Component#new","content":"Component &lt;/&gt; Component.new(config: ComponentConfig) → ComponentClass Create a new custom Component class. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) A full example might look like this: local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, Extensions = {Logger}, -- See Logger example within the example for the Extension type }) local AnotherComponent = require(somewhere.AnotherComponent) -- Optional if UpdateRenderStepped should use BindToRenderStep: MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:Construct() self.MyData = &quot;Hello&quot; end function MyComponent:Start() local another = self:GetComponent(AnotherComponent) another:DoSomething() end function MyComponent:Stop() self.MyData = &quot;Goodbye&quot; end function MyComponent:HeartbeatUpdate(dt) end function MyComponent:SteppedUpdate(dt) end function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"HeartbeatUpdate​","type":1,"pageTitle":"Component","url":"api/Component#HeartbeatUpdate","content":"Component Class &lt;/&gt; Component.HeartbeatUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Heartbeat. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:HeartbeatUpdate(dt) end   "},{"title":"SteppedUpdate​","type":1,"pageTitle":"Component","url":"api/Component#SteppedUpdate","content":"Component Class &lt;/&gt; Component.SteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Stepped. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:SteppedUpdate(dt) end   "},{"title":"RenderSteppedUpdate​","type":1,"pageTitle":"Component","url":"api/Component#RenderSteppedUpdate","content":"This item only works when running on the client. Client Component Class &lt;/&gt; Component.RenderSteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.RenderStepped. If the [Component].RenderPriority field is found, then the component will instead use RunService:BindToRenderStep() to bind the function. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. -- Example that uses `RunService.RenderStepped` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:RenderSteppedUpdate(dt) end -- Example that uses `RunService:BindToRenderStep` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- Defining a RenderPriority will force the component to use BindToRenderStep instead MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"GetAll​","type":1,"pageTitle":"Component","url":"api/Component#GetAll","content":"Component Class &lt;/&gt; Component:GetAll() → {Component} Gets a table array of all existing component objects. For example, if there was a component class linked to the &quot;MyComponent&quot; tag, and three Roblox instances in your game had that same tag, then calling GetAll would return the three component instances. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- ... local components = MyComponent:GetAll() for _,component in ipairs(components) do component:DoSomethingHere() end   "},{"title":"FromInstance​","type":1,"pageTitle":"Component","url":"api/Component#FromInstance","content":"Component Class &lt;/&gt; Component:FromInstance(instance: Instance ) → Component? Gets an instance of a component class from the given Roblox instance. Returns nil if not found. local MyComponent = require(somewhere.MyComponent) local myComponentInstance = MyComponent:FromInstance(workspace.SomeInstance)   "},{"title":"WaitForInstance​","type":1,"pageTitle":"Component","url":"api/Component#WaitForInstance","content":"Component Class &lt;/&gt; Component:WaitForInstance( instance: Instance , timeout: number? ) → Promise&lt;ComponentInstance&gt; Resolves a promise once the component instance is present on a given Roblox instance. An optional timeout can be provided to reject the promise if it takes more than timeout seconds to resolve. If no timeout is supplied, timeout defaults to 60 seconds. local MyComponent = require(somewhere.MyComponent) MyComponent:WaitForInstance(workspace.SomeInstance):andThen(function(myComponentInstance) -- Do something with the component class end)   "},{"title":"Construct​","type":1,"pageTitle":"Component","url":"api/Component#Construct","content":"Component Class &lt;/&gt; Component:Construct() → () Construct is called before the component is started, and should be used to construct the component instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Construct() self.SomeData = 32 self.OtherStuff = &quot;HelloWorld&quot; end   "},{"title":"Start​","type":1,"pageTitle":"Component","url":"api/Component#Start","content":"Component Class &lt;/&gt; Component:Start() → () Start is called when the component is started. At this point in time, it is safe to grab other components also bound to the same instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() -- e.g., grab another component: local another = self:GetComponent(AnotherComponent) end   "},{"title":"Stop​","type":1,"pageTitle":"Component","url":"api/Component#Stop","content":"Component Class &lt;/&gt; Component:Stop() → () Stop is called when the component is stopped. This occurs either when the bound instance is removed from one of the whitelisted ancestors or when the matching tag is removed from the instance. This also means that the instance might be destroyed, and thus it is not safe to continue using the bound instance (e.g. self.Instance) any longer. This should be used to clean up the component. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Stop() self.SomeStuff:Destroy() end   "},{"title":"GetComponent​","type":1,"pageTitle":"Component","url":"api/Component#GetComponent","content":"Component Instance &lt;/&gt; Component:GetComponent(componentClass: ComponentClass) → Component? Retrieves another component instance bound to the same Roblox instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() local another = self:GetComponent(AnotherComponent) end  "}]