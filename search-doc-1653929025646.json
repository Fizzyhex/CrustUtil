[{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Wally Configuration​","type":1,"pageTitle":"Getting Started","url":"docs/intro#wally-configuration","content":"Once Wally is installed, run wally init on your project directory. This will create a brand new wally.toml file. You can then add any utilities you would like to your project as dependancies. For example: [package] name = &quot;your_name/your_project&quot; version = &quot;0.1.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] UIComponent = &quot;virshal/uicomponent@0.2.1&quot; Copy To install or update these dependancies, run wally install within your project's terminal. Wally will then create a folder called 'Packages' with all of your installed dependancies! "},{"title":"Rojo Configuration​","type":1,"pageTitle":"Getting Started","url":"docs/intro#rojo-configuration","content":"I would suggest checking out this guide by Sleitnick for his RbxUtil modules, which inspired this guide! "},{"title":"Usage Example​","type":1,"pageTitle":"Getting Started","url":"docs/intro#usage-example","content":"Information about the respective packages can be found in the API section. Below is an example of a script using installed dependancies: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) -- Reference the packages folder: local Packages = ReplicatedStorage.Packages -- Require package: local UIComponent = require(ReplicatedStorage.Packages.UIComponent) local CreateInstance = UIComponent.CreateInstance -- Use the module: local Button = UIComponent.new() function Button:Build() self.button = CreateInstance &quot;TextButton&quot; { Size = UDim2.new(0, 200, 0, 50), Text = &quot;Click Me!&quot; TextColor3 = self.props.textColor, Parent = self.props.parent } end local gui = CreateInstance(&quot;ScreenGui&quot;, {Parent = LOCAL_PLAYER.PlayerGui}) local newButton = Button{textColor = Color3.new(1, 0.5, 0.5), parent = gui} Copy "},{"title":"KnitUtil","type":0,"sectionRef":"#","url":"api/KnitUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"KnitUtil","url":"api/KnitUtil#functions","content":" "},{"title":"LoadComponents​","type":1,"pageTitle":"KnitUtil","url":"api/KnitUtil#LoadComponents","content":"&lt;/&gt; KnitUtil.LoadComponents( container: Instance -- The folder containing the Components ) → table{Component} Requires all children of the provided Instance. -- Require the module local KnitUtil = require(somewhere.KnitUtil) -- Locate components folder local componentsFolder = ReplicatedStorage.Client.Components -- Load all of the components local components = KnitUtil.LoadComponents(componentsFolder)   "},{"title":"MethodFromInstance​","type":1,"pageTitle":"KnitUtil","url":"api/KnitUtil#MethodFromInstance","content":"&lt;/&gt; KnitUtil.MethodFromInstance( instance: Instance ,-- The Instance to search methodName: string-- The name of the method to look for ) → ( methodfunction?,-- The method that was found componentComponent?-- The component instance the method belongs to ) Searches all the Instance's components for a specific method. Writing cleaner code with MethodFromInstance Let's say we have two components: a door and a light switch. We want to write a script to interact with these objects and any new ones we may come up with in the future: Door Component local Door = Component.new { Tag = &quot;Door&quot; } function Door:_open() print(&quot;Door open&quot;) self.isOpen = true end function Door:_close() print(&quot;Door closed&quot;) self.isOpen = false end function Door:OnInteract(open: boolean) if open then if self.isOpen then self:_close() else self:_open() end end end function Door:Construct() self.isOpen = false end Light Switch Component local LightSwitch = Component.new { Tag = &quot;LightSwitch&quot; } function LightSwitch:_turnOn() print(&quot;Light on&quot;) self.isOn = true end function LightSwitch:_turnOff() print(&quot;Light off&quot;) self.isOn = false end function LightSwitch:OnInteract(on: boolean) if on then if self.isOn then self:_turnOff() else self:_turnOn() end end end function LightSwitch:Construct() self.isOn = false end Interaction Script (without MethodFromInstance) Without MethodFromInstance, we might write some interaction code like this: -- Require components we can interact with local DoorComponent = require(somewhere.Components.DoorComponent) local LightSwitchComponent = require(somewhere.Components.LightSwitch) local function InteractWith(instance: Instance) -- Scan through the Instance's components for an 'OnInteract' method if CollectionService:HasTag(instance, &quot;Door&quot;) then DoorComponent:FromInstance(instance):OnInteract(true) elseif CollectionService:HasTag(instance, &quot;LightSwitch&quot;) then LightSwitchComponent:FromInstance(instance):OnInteract(true) else if ....... then -- etc etc etc ..... end end -- Open the door InteractWith(workspace.Door) -- Flick the light switch to on InteractWith(workspace.LightSwitch) Final Result (using MethodFromInstance) This code is bad because it will get messy as we add more types of Components to our game. However, if we instead use MethodFromInstance we don't need to modify the code every time we create a new component. Below is an example that implements MethodFromInstance: local function InteractWith(instance: Instance) -- Scan through the Instance's components for an 'OnInteract' method local onInteract = KnitUtil.MethodFromInstance(instance, &quot;OnInteract&quot;) if onInteract then -- Call the method onInteract(true) end end -- Open the door InteractWith(workspace.Door) -- Flick the light switch to on InteractWith(workspace.LightSwitch)   "},{"title":"VariableFromInstance​","type":1,"pageTitle":"KnitUtil","url":"api/KnitUtil#VariableFromInstance","content":"&lt;/&gt; KnitUtil.VariableFromInstance( instance: Instance ,-- The Instance to search variableName: string-- The variable to look for ) → ( variableany,-- The variable that was found componentComponent?-- The component instance the method belongs to ) Similar to MethodFromInstance, but for non-methods. local function GetHealth(enemy: Instance) local health: number? = KnitUtil.VariableFromInstance(enemy, &quot;MyHealth&quot;) return health end print(GetHealth(workspace.Zombie)) print(GetHealth(workspace.Player)) print(GetHealth(workspace.DestructableBox))  "},{"title":"UIComponent","type":0,"sectionRef":"#","url":"api/UIComponent","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#functions","content":" "},{"title":"CreateInstance​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#CreateInstance","content":"&lt;/&gt; UIComponent.CreateInstance( className: string,-- The class name of the Instance you want to create props: table-- The properties of the instance you want to create ) → Instance -- Returns a new Instance A utility for creating Instances. local smokeyCube = CreateInstance(&quot;BasePart&quot;, { Name = &quot;SmokeyCube&quot;, Anchored = true, Size = Vector3.new(4, 4, 4) Parent = workspace [UIComponent.Children] = CreateInstance(&quot;Smoke&quot;, { Size = 4 }) }) -- ...which is equivalent to: local smokeyCube = Instance.new(&quot;BasePart&quot;) smokeyCube.Name = &quot;SmokeyCube&quot; smokeyCube.Anchored = true smokeyCube.Size = Vector3.new(4, 4, 4) smokeyCube.Parent = workspace local smoke = Instance.new(&quot;Smoke&quot;) smoke.Size = 4 smoke.Parent = smokeyCube Assigning children Assigning children can be done within the CreateInstance function. The simplist way to do this is to simply pass a child: local gui = CreateInstance(&quot;ScreenGui&quot;, { Parent = PlayerGui, Children = CreateInstance(&quot;Frame&quot;, { Size = UDim2.new(0, 50, 0, 50), }), }) Or a table for multiple children: local gui = CreateInstance(&quot;ScreenGui&quot;, { Parent = PlayerGui, Children = { CreateInstance(&quot;Frame&quot;, { Size = UDim2.new(0, 50, 0, 50), }), CreateInstance(&quot;TextButton&quot;, { Size = UDim2.new(0, 50, 0, 50), }), } }) If you ever need to, you can also specify multiple children under different keys using the UIComponent.Children Enum: local gui = CreateInstance(&quot;ScreenGui&quot;, { Parent = PlayerGui, [UIComponent.Children] = { CreateInstance(&quot;Frame&quot;, { Size = UDim2.new(0, 50, 0, 50), }), } [UIComponent.Children] = { CreateInstance(&quot;TextButton&quot;, { Size = UDim2.new(0, 50, 0, 50), }), } })   "},{"title":"Is​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#Is","content":"&lt;/&gt; UIComponent.Is( thing: any-- Object to check ) → boolean-- true if object is a UIComponent. Checks if the given object is a UIComponent object.  "},{"title":"new​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#new","content":"&lt;/&gt; UIComponent.new() → UIComponent Creates a new UIComponent class. local newComponent = UIComponent.new()   "},{"title":"GetInstance​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#GetInstance","content":"&lt;/&gt; UIComponent:GetInstance() → Instance  Returns the Instance returned by the component when it was built. This function will error if the component does not have an Instance. local Button = UIComponent.new() function Button:Build() return CreateInstance &quot;TextButton&quot; { Name = &quot;FriendlyButton&quot;, Size = UDim2.new(0, 100, 0, 50), Text = self.props.Text, }, self.props end local newButton, _, props = Button {Text = &quot;Hello World!&quot;} print(newButton:GetInstance()) print(props) &gt; FriendlyButton &gt; { Text = &quot;Hello World!&quot; }   "},{"title":"Build​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#Build","content":"&lt;/&gt; UIComponent:Build() → self,...-- Returns the object and any provided arguments Build is called during the UIComponent's creation. Build should not be called to create a new Instance of a UIComponent. Instead, call it like a function. local UIComponent = require(somewhere.UIComponent) local PersistentGui = UIComponent.new() function PersistentGui:Build() self.gui = CreateInstance(&quot;ScreenGui&quot;, { Name = &quot;PersistentGui&quot;, ResetOnSpawn = false, ZIndex = self.props.ZIndex, Parent = LOCAL_PLAYER.PlayerGui }) return self.gui, tick() end local persistentGui, _, creationTime = MainGui.new{ ZIndex = 3 } print(&quot;Created GUI at&quot;, creationTime)   "},{"title":"Defer​","type":1,"pageTitle":"UIComponent","url":"api/UIComponent#Defer","content":"&lt;/&gt; UIComponent:Defer() → () Defer is called after Build and will not yield the thread. "}]